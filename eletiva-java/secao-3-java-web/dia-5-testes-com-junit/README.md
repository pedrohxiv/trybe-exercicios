# :pencil: Testes com JUnit

O objetivo dos exerc√≠cios desse dia foi aprender um pouco sobre testes em Java, de modo a garantir a qualidade dos c√≥digos. Para isso deveria entender a import√¢ncia de testes, criar testes em Java com JUnit 5, aplicar o TDD (Test Driven Development) em Java, utilizar JUni5 com Spring e construir testes em aplica√ß√µes Spring, especialmente nas REST.

Os requisitos dos exerc√≠cios s√£o:

# Caixa Eletr√¥nico

Para todos os requisitos, iremos implementar os testes unit√°rios, e depois iremos implementar o c√≥digo para que nossos testes passem. Se necess√°rio, iremos refatorar o c√≥digo para deixar cada vez mais limpo.

<details>
    <summary>Entendendo o Sistema</summary>

Os passos a seguir s√£o para construir as classes essenciais para o nosso sistema de caixa eletr√¥nico. Vamos juntos nesta jornada, criando, testando e aperfei√ßoando a nossa cria√ß√£o.

Lembre-se, nosso objetivo √© um caixa eletr√¥nico, eficiente e seguro, por isso cada etapa √© crucial. Vamos nessa!

<details>
    <summary>Classe Banco</summary>

- `Banco`: representa a entidade banco do nosso caixa eletr√¥nico. Essa classe √© a respons√°vel por criar novas pessoas clientes no banco e tamb√©m verificar e validar o login da pessoa cliente no caixa eletr√¥nico.

  - Atributos:

    - `pessoasClientes`: esse atributo √© um array de objetos da classe `PessoaCliente` (ex: ArrayList<PessoaCliente>), e representa a lista de pessoas clientes que tem contas abertas no banco (uma pessoa cliente pode ter mais de uma conta aberta).
    - `contas`: esse atributo √© um array de objetos da classe `Contas` (ex: ArrayList<Conta>) e representa a lista de contas abertas no banco, onde cada uma pertence a uma pessoa cliente. As contas s√£o identificadas por uma String de 10 d√≠gitos, que representa um n√∫mero identificador √∫nico gerado pelo m√©todo `gerarNumeroNovaConta` da classe `Banco`.

  - M√©todos:
    - `gerarNumeroNovaConta`: esse m√©todo √© p√∫blico, deve retornar uma String e n√£o recebe nenhum argumento. Ele √© respons√°vel por gerar e retornar uma String de 10 d√≠gitos, que representa o n√∫mero identificador √∫nico de uma conta, ou seja, para cada nova conta aberta, ele deve gerar um n√∫mero √∫nico (ex: "8514540006").
    - `adicionarPessoaCliente`: esse m√©todo √© p√∫blico, retorna um objeto do tipo `PessoaCliente` e deve receber 4 argumentos do tipo String (nome, tipoConta, cpf, e senha). Esse m√©todo deve instanciar um objeto da classe `PessoaCliente` e adicion√°-lo no array `pessoasClientes`, tamb√©m deve instanciar um objeto da classe `Conta` e adicion√°-lo no array `contas`. Depois disso, deve adicionar essa nova conta √† pessoa cliente que acabou de ser criada atrav√©s do m√©todo `adicionarConta` da classe `PessoaCliente`. Por fim, esse m√©todo deve retornar esse objeto da classe `PessoaCliente` criado.
    - `adicionarConta`: esse m√©todo √© p√∫blico e tem o retorno do tipo `void`, ou seja, n√£o retorna nenhum valor e recebe 1 argumento (novaConta) do tipo `Conta`. Esse m√©todo √© respons√°vel por receber uma conta como par√¢metro e adicionar ao array `contas`.
    - `pessoaClienteLogin`: esse m√©todo √© p√∫blico, retorna um objeto do tipo `PessoaCliente` e recebe 2 argumentos do tipo String (cpf e senha). Ele √© respons√°vel por buscar no array `pessoasClientes` , o objeto que √© dono do cpf passado por par√¢metro e verificar se a senha est√° correta. Caso o cpf e a senha sejam de algum objeto que est√° no array `pessoasClientes`, o objeto que representa a pessoa cliente deve ser retornado; caso contr√°rio, esse m√©todo deve retornar `null`.
    - `transferirFundos`: esse m√©todo √© p√∫blico, deve ter o retorno do tipo `void` (n√£o retorna nenhum valor) e deve receber quatro atributos, que s√£o`pessoaCliente`, do tipo da classe `PessoaCLiente`(representando a pessoa cliente logada); `daConta`, do tipo inteiro que representa o √≠ndice no array `contas` da conta (respons√°vel por ceder o dinheiro para a transfer√™ncia); `paraConta`, do tipo inteiro que representa o √≠ndice no array `contas` (para a conta que receber√° a transfer√™ncia); e por fim, `quantia`, que √© do tipo `double` (representa o valor que ser√° transferido).
    - `sacar`: esse m√©todo √© p√∫blico, deve ter o retorno do tipo `void` (n√£o retorna nenhum valor) e deve receber tr√™s atributos, que s√£o `pessoaCliente`, do tipo da classe `PessoaCLiente` (representando a pessoa cliente logada); `daConta`, do tipo inteiro (representando o √≠ndice no array `contas` da conta na qual ser√° sacado o dinheiro); e por fim, `quantia`, que √© do tipo `double` (representa o valor que ser√° sacado).
    - `depositar`: esse m√©todo √© p√∫blico, deve ter o retorno do tipo `void` (n√£o retorna nenhum valor) e deve receber tr√™s atributos, que s√£o `pessoaCliente`, do tipo da classe `PessoaCLiente` (representa a pessoa cliente logada); `paraConta`, do tipo inteiro (representa o √≠ndice no array `contas` da conta na qual ser√° depositado o dinheiro); e por fim, `quantia`, que √© do tipo `double` (representa o valor que ser√° depositado).
    - `mostrarExtrato`: esse m√©todo tamb√©m √© p√∫blico, deve ter o retorno do `void`, e deve receber dois atributos, que s√£o pessoaCliente, do tipo da classe `PessoaCliente` (que representa a pessoa cliente dona da conta) e o `conta`, que √© do tipo inteiro (representa o √≠ndice da conta que ser√° mostrada o extrato no array `contas`).

**Olha a dica:** üëÄ no m√©todo `gerarNumeroNovaConta`, utilize o m√©todo `nextInt`, da classe `Random` do pacote `java.util`, para gerar os d√≠gitos. Gere um d√≠gito de cada vez e concatene em uma String. Ao final, verifique se algum objeto conta j√° criado tem esse mesmo n√∫mero identificador. Caso tenha, realize o processo novamente at√© ser gerado um identificador √∫nico. E no m√©todo `transferirFundos` considere que uma pessoa cliente s√≥ pode transferir dinheiro entre as suas pr√≥prias contas, uma conta corrente e uma conta poupan√ßa.

</details>

<details>
    <summary>Classe Conta</summary>

- `Conta`: representa as contas do banco, onde temos os m√©todos relacionados √†s transa√ß√µes, e mostra as informa√ß√µes de saldo.

  - Atributos:

    - `tipoConta`: atributo do tipo String que indica se a conta √© "Poupan√ßa" ou "Corrente".
    - `idConta`: atributo do tipo String que representa o n√∫mero de identifica√ß√£o √∫nico da conta banc√°ria.
    - `pessoaCliente`: atributo do tipo `PessoaCliente`, que representa a pessoa cliente dona da conta em quest√£o.
    - `transacoes`: esse atributo √© um array de objetos da classe `Transacao` (ex: ArrayList<Transacao>), respons√°vel por armazenar todas as transa√ß√µes realizadas na conta.

  - M√©todos:
    - Construtor: esse m√©todo construtor deve receber como argumentos `tipoConta` do tipo String; `pessoaCliente` do tipo da classe `PessoaCliente`; e `banco` do tipo da classe `Banco`. Ele deve utilizar esses argumentos para inicializar os respectivos atributos e utilizar o m√©todo `gerarNumeroNovaConta` para gerar o n√∫mero de identificador √∫nico para a conta.
    - `adicionarTransacao`: esse m√©todo √© p√∫blico e de retorno do tipo `void`. Deve receber dois argumentos, que s√£o `quantia` do tipo `double` e a `descricao` do tipo String. `quantia` indica o valor que envolve a transa√ß√£o e `descricao` indica que tipo de transa√ß√£o foi realizada (ex: Dep√≥sito recebido, Saque efetuado, etc.). Deve-se usar esses valores para instanciar um objeto da classe `Transacao`, passando a quantia e a descri√ß√£o (ex: `Transacao novaTransacao = new Transacao(quantia, "Transfer√™ncia recebida");`) e adicionando esse novo objeto no array `transacoes`.
    - `retornarSaldo`: esse m√©todo √© p√∫blico e retorna o tipo `double`. Ele usa o array `transacoes` para calcular o saldo da conta em quest√£o.
    - `retornarResumoConta`: √© do tipo p√∫blico e retorna um String com o resumo da conta, n√∫mero de identifica√ß√£o √∫nico, saldo e tipo da conta (Poupan√ßa ou Corrente). Ele usa o m√©todo `retornarSaldo` para calcular o saldo da conta.
    - `retornarExtrato`: esse m√©todo √© p√∫blico e tem retorno do tipo `void`. Esse m√©todo imprime no console todas as transa√ß√µes (uma por linha) da conta. Em outras palavras, esse m√©todo percorre o array `transacoes` e para cada objeto desse array, chama o m√©todo `retornarResumoTransacao` da classe `Transacao`.
    - `getIdConta`: m√©todo `Getter` do atributo `idConta`.
    - `getPessoaCliente`: m√©todo `Getter` do atributo `pessoaCliente`.

‚ö†**Aten√ß√£o‚ö†:** perceba que a soma das transa√ß√µes indica o saldo da conta, onde saques e transfer√™ncias enviadas s√£o valores negativos e os dep√≥sitos e transfer√™ncias recebidos s√£o valores positivos nessa soma.

</details>

<details>
    <summary>Classe PessoaCliente</summary>

- `PessoaCliente`: essa classe representa as pessoas clientes do banco.

  - Atributos:

    - `nomeCompleto`: atributo do tipo String para armazenar o nome da pessoa cliente.
    - `cpf`: atributo do tipo String para armazenar o CPF da pessoa cliente.
    - `senha`: atributo do tipo String para armazenar a senha da pessoa cliente.
    - `contas`: esse atributo √© um array de objetos da classe `Conta` (ex: ArrayList<Conta>), respons√°vel por armazenar todas as contas que a pessoa cliente possui.

  - M√©todos:
    - Construtor: inicializa os atributos da classe `PessoaCliente` e recebe tr√™s atributos do tipo String, que s√£o `nome`, ` cpf`` e  `senha`. Esses argumentos s√£o utilizados para inicializar os respectivos atributos. Por fim, esse m√©todo construtor imprime uma mensagem no console indicando que a pessoa cliente foi criada (ex: "Nova pessoa cliente Alexiania Silva com CPF: 433.892.200-11 criada!")
    - `adicionarConta`: esse m√©todo √© p√∫blico e deve ter o retorno do tipo `void`. Ele recebe um argumento `conta`, do tipo da classe `Conta`, e adiciona ele no array `contas`.
    - `retornaNumeroDeContas`: m√©todo p√∫blico que retorna um inteiro (n√£o recebe nenhum argumento). O inteiro que √© retornado por esse m√©todo √© a quantidade de objetos no array `contas`, ou seja, o seu tamanho.
    - `retornarSaldoContaEspecifica`: esse m√©todo √© p√∫blico e retorna um valor do tipo `double`, recebendo como argumento um `indice` do tipo inteiro (para ser usado como √≠ndice no array `contas`) e usando o m√©todo `retornarSaldo` da classe `Conta` para retornar o saldo.
    - `retornarIdContaEspecifica`: esse m√©todo √© p√∫blico e retorna um valor do tipo String, recebendo um argumento `indice` do tipo inteiro (para ser usado como √≠ndice no array `contas`) e usando o m√©todo `getIdConta` da classe `Conta` para retornar o n√∫mero identificador √∫nico da conta.
    - `retornarExtratoContaEspecifica`: esse m√©todo √© p√∫blico e tem um retorno do tipo `void`, recebendo um argumento `indice` do tipo inteiro (para ser usado como √≠ndice no array `contas`) e usando o m√©todo `retornarExtrato` da classe `Conta` para imprimir todas as transa√ß√µes de uma determinada conta.
    - `adicionarTransacaoContaEspecifica`: esse m√©todo p√∫blico e tem retorno do tipo `void`, recebendo 3 argumentos, que s√£o `indice` do tipo inteiro, `quantia` do tipo `double` e `descricao` do tipo String. Esse m√©todo utiliza o argumento `indice` para selecionar uma conta espec√≠fica dentro do array `contas` e chama o m√©todo `adicionarTransacao` da classe `Conta` para adicionar uma transa√ß√£o e passar os argumentos `quantia` e `descricao`.
    - `validarSenha`: esse m√©todo √© p√∫blico e retorna um valor `boolean`, recebendo um argumento `senha` do tipo String e verificando se essa String √© igual ao atributo `senha` do objeto. Se for, retorna `true`, se n√£o for retorna `false`.
    - `retornarResumoContas`: esse m√©todo √© p√∫blico e tem retorno do tipo `void`. Ele n√£o recebe argumento e percorre o array `contas`, utilizando o m√©todo `retornarResumoConta` da classe `Conta` para imprimir o resumo da conta.
    - `getCpf`: m√©todo `Getter` do atributo `cpf`.

</details>

<details>
    <summary>Classe Transacao</summary>

- `Transacao`: essa classe √© utilizada para representar a transa√ß√£o nas contas do banco.

  - Atributos:

    - `quantia`: esse atributo √© do tipo `double` e representa o valor da transa√ß√£o.
    - `instante`: esse atributo √© do tipo String e armazena a data e a hora que a transa√ß√£o ocorreu.
    - `descricao`: esse atributo √© do tipo String e armazena a descri√ß√£o da transa√ß√£o.
    - `conta`: esse atributo √© do tipo `Conta` e armazena o objeto `conta` da transa√ß√£o.

  - M√©todos:
    - Construtor: esse m√©todo recebe dois argumentos, que s√£o `quantia` do tipo `double` e `descricao` do tipo String. Ele usa esses argumentos para inicializar seus respectivos atributos e chama o m√©todo `retornarInstante` para armazenar a data e a hora que essa transa√ß√£o foi realizada.
    - `getQuantia`: m√©todo `Getter` do atributo `quantia`.
    - `retornarResumoTransacao`: esse m√©todo √© p√∫blico e retorna uma String que representa o resumo da transa√ß√£o, contendo as informa√ß√µes instante, quantia e descri√ß√£o. Ele n√£o recebe nenhum argumento.
    - `retornarInstante`: esse m√©todo √© p√∫blico e retorna um String que representa o instante em que esse m√©todo √© invocado. Ele usa a classe `LocalDateTime` para recuperar o momento em que o m√©todo √© invocado (`LocalDateTime.now()`) e a classe `DateTimeFormatter` para formatar para o padr√£o brasileiro (ex: 20/01/2022 10:24:30). Esse m√©todo √© usado no m√©todo construtor para inicializar o atributo `instante`.

</details>

<details>
    <summary>Classe CaixaEletronico - m√©todo main </summary>

![MapaMental](images/mapa_mental_classes.png)

Para ajudar, implemente agora a classe `CaixaEletronico`, que cont√©m o m√©todo `main`. Dessa forma, voc√™ ter√° um ponto de partida. Agora siga o passo a passo abaixo: üëá

1. Primeiro importe a classe `Scanner`, e ent√£o escreva o m√©todo `main`. Aqui voc√™ deve instanciar um objeto da classe `Banco` e us√°-la para criar tr√™s pessoas clientes e duas contas para cada pessoa cliente.

‚ö†**Aten√ß√£o‚ö†:** Ap√≥s a cria√ß√£o das pessoas clientes e suas respectivas contas banc√°rias, voc√™ vai entrar em um la√ßo infinito que √© o sistema do caixa eletr√¥nico em si. A princ√≠pio ele mostra uma mensagem de boas-vindas e permite que a pessoa cliente possa entrar com seus dados para poder acessar sua conta.

Se a pessoa cliente entrar com os dados incorretos, o fluxo do programa vai entrar na primeira condi√ß√£o (`if`) e reapresentar√° a mensagem de boas-vindas e os campos para que a pessoa cliente possa tentar novamente. Quando a pessoa cliente entra com os dados corretos, o fluxo do sistema entra na segunda condi√ß√£o (`else`) e √© apresentado um menu para manipula√ß√£o das suas contas banc√°rias.

2. Na segunda etapa voc√™ ver√° um resumo das contas banc√°rias da pessoa usu√°ria e tamb√©m um menu com cinco op√ß√µes (quatro delas para manipular a sua conta banc√°ria e a quinta para fazer o logout do sistema e voltar para a tela de boas-vindas com os campos para fazer o login).

üëÄObserve que cada op√ß√£o √© uma condi√ß√£o `if`/`else`! Dentro delas fazemos os tratamentos de dados inseridos de forma errada, com mensagens que indiquem o que foi que a pessoa cliente errou. J√° quando os dados s√£o inseridos corretamente, chamamos os respectivos m√©todos do banco para realizar a opera√ß√£o relativa √† op√ß√£o selecionada.

<details>
    <summary>Poss√≠vel implementa√ß√£o Classe CaixaEletronico </summary>

‚ö†**Aten√ß√£o‚ö†:** essa classe `CaixaEletronico` √© a principal do nosso sistema, pois ela cont√©m o m√©todo `main` e como podemos ver na implementa√ß√£o, ele √© o respons√°vel por toda a intera√ß√£o com a pessoa cliente.

Em outras palavras, essa classe √© a interface entre a pessoa cliente e nosso sistema do banco. Com ela e as informa√ß√µes descritas anteriormente sobre as classes e seus m√©todos, voc√™ conseguir√° entregar essa demanda com sucesso! üöÄ

```java
package com.trybe.caixaeletronico;

import java.util.Scanner;

public class CaixaEletronico {

  public static void main(String[] args) {

    Scanner sc = new Scanner(System.in);

    Banco banco = new Banco();

    /* adiciona algumas pessoas clientes ao banco criando ja uma conta poupanca
     * e em seguida adiciona uma conta corrente para essas pessoas
     */

    // pessoa cliente 1
    PessoaCliente pessoaCliente1 = banco.adicionarPessoaCliente("Alexiania Pereira", "842.074.410-77", "1234");
    banco.adicionarConta("Poupan√ßa", pessoaCliente1);
    banco.adicionarConta("Corrente", pessoaCliente1);

    // pessoa cliente 2
    PessoaCliente pessoaCliente2 = banco.adicionarPessoaCliente("Abadiania Silva", "848.725.510-87", "1234");
    banco.adicionarConta("Poupan√ßa", pessoaCliente2);
    banco.adicionarConta("Corrente", pessoaCliente2);

    // pessoa cliente 3
    PessoaCliente pessoaCliente3 = banco.adicionarPessoaCliente("Camaragibe Oliveira", "433.892.200-11", "1234");
    banco.adicionarConta("Poupan√ßa", pessoaCliente3);
    banco.adicionarConta("Corrente", pessoaCliente3);
    // laco infinito
    while (true) {

      System.out.println("\n\nBem-vindo ao Banco da Trybe\n\n");
      System.out.print("Entre com seu CPF: ");
      String pessoaClienteCpf = sc.nextLine();
      System.out.print("Entre com sua senha: ");
      String senha = sc.nextLine();

      PessoaCliente pessoaClienteAutenticada = banco.pessoaClienteLogin(pessoaClienteCpf, senha);

      if (pessoaClienteAutenticada == null) {
        System.out.println("Combina√ß√£o de CPF e senha incorretos. Tente novamente");

      } else {

        int op;

        // menu para manipulacao das contas da pessoa cliente
        do {

          // mostra o resumo das contas da pessoa cliente
          pessoaClienteAutenticada.retornarResumoContas();

          System.out.println("O que voc√™ gostaria de fazer?");
          System.out.println("  1) Mostrar Extrato");
          System.out.println("  2) Sacar");
          System.out.println("  3) Depositar");
          System.out.println("  4) Transferir");
          System.out.println("  5) Sair");
          System.out.println();
          System.out.print("Entre com sua op√ß√£o: ");

          op = sc.nextInt();

          if (op < 1 || op > 5) {
            System.out.println("Op√ß√£o inv√°lida, escolha uma op√ß√£o v√°lida.");
          }

          // processando a escolha
          if (op == 1) {

            int conta;

            // pega o indice da conta para imprimir o extrato
            do {
              System.out.printf("Entre com o n√∫mero (1-%d) para a conta\nque "
                                       + "o extrato ser√° impresso: ", pessoaClienteAutenticada.retornaNumeroDeContas());
              conta = sc.nextInt() - 1;
              if (conta < 0 || conta >= pessoaClienteAutenticada.retornaNumeroDeContas()) {
                System.out.println("N√∫mero inv√°lido, tente novamente.");
              }else {
                break;
              }
            } while (true);

            banco.mostrarExtrato(pessoaClienteAutenticada, conta);

          } else if (op == 2) {

            int deConta;
            double quantia;
            double saldoConta;

            // pega o indice da conta para saque
            do {
              System.out.printf("Entre o n√∫mero (1-%d) para selecionar a conta para "
                                   + "o saque: ", pessoaClienteAutenticada.retornaNumeroDeContas());
              deConta = sc.nextInt() - 1;
              if (deConta < 0 || deConta >= pessoaClienteAutenticada.retornaNumeroDeContas()) {
                System.out.println("√çndice de conta inv√°lido, tente novamente.");
              } else {
                break;
              }
            } while (true);

            // retorna o saldo da conta selecionada para ver se tem fundos suficientes
            saldoConta = pessoaClienteAutenticada.retornarSaldoContaEspecifica(deConta);

            // pega a quantia para o saque
            do {
              System.out.printf("Entre com a quantia a ser sacada (m√°ximo R$%.02f): R$ ", saldoConta);
              quantia = sc.nextDouble();
              if (quantia < 0) {
                System.out.println("quantia deve ser maior que zero.");
              } else if (quantia > saldoConta) {
                System.out.printf("quantia n√£o pode ser maior que o saldo "
                                        + "de R$ %.02f.\n", saldoConta);
              } else {
                break;
              }
            } while (true);

            banco.sacar(pessoaClienteAutenticada, deConta, quantia);

          } else if (op == 3) {

            int paraConta;
            double quantia;

            // pega o indice da conta para deposito
            do {
              System.out.printf("Entre com o n√∫mero (1-%d) para selecionar a conta para "
                                     + "dep√≥sito: ", pessoaClienteAutenticada.retornaNumeroDeContas());
              paraConta = sc.nextInt() - 1;

              if (paraConta < 0 || paraConta >= pessoaClienteAutenticada.retornaNumeroDeContas()) {
                System.out.println("√çndice de conta inv√°lido, tente novamente.");

              } else {
                break;
              }
            } while (true);

            // pega quantia para depositar
            do {
              System.out.printf("Entre com a quantia de dep√≥sito: R$ ");
              quantia = sc.nextDouble();

              if (quantia < 0) {
                System.out.println("quantia deve ser maior que zero.");

              } else {
                break;
              }
            } while (true);

            // realiza o deposito
            banco.depositar(pessoaClienteAutenticada, paraConta, quantia);

          } else if (op == 4) {

            int daConta;
            int paraConta;
            double quantia;
            double saldoConta;

            // pega o indice de uma conta retirar o valor da transferencia
            do {
              System.out.printf("Entre o n√∫mero (1-%d) para "
            	                      + "retirar o valor para transfer√™ncia: ", pessoaClienteAutenticada.retornaNumeroDeContas());
              daConta = sc.nextInt() - 1;
              if (daConta < 0 || daConta >= pessoaClienteAutenticada.retornaNumeroDeContas()) {
                System.out.println("√çndice de conta inv√°lido, tente novamente.");
              } else {
                break;
              }
            } while (true);

            // retorna o saldo da conta selecionada para ver se tem fundos suficientes
            saldoConta = pessoaClienteAutenticada.retornarSaldoContaEspecifica(daConta);

            // pega o indice da conta que vai receber o valor da transferencia
            do {
              System.out.printf("Entre o n√∫mero (1-%d) para "
                                     + "selecionar a conta que receber√° a transfer√™ncia: ", pessoaClienteAutenticada.retornaNumeroDeContas());
              paraConta = sc.nextInt() - 1;
              if (paraConta < 0 || paraConta >= pessoaClienteAutenticada.retornaNumeroDeContas()) {
                System.out.println("√çndice de conta inv√°lido, tente novamente.");
              } else {
                break;
              }
            } while (true);

            // pega o valor para transferir
            do {
              /* pega a quantia para ser transferida de uma conta da pessoa cliente para outra
               * levando em consideracao o saldo da conta que cedera o dinheiro
               */
              System.out.printf("Entre com a quantia para ser transferida (m√°ximo R$%.02f): R$ ", saldoConta);
              quantia = sc.nextDouble();

              if (quantia < 0) {
                System.out.println("quantia deve ser maior que zero.");

              } else if (quantia > saldoConta) {
                System.out.printf("quantia n√£o pode ser maior que o valor do saldo "
                                       + "de R$.02f.\n", saldoConta);
              } else {
                break;
              }
            } while (true);

            // envia as informacoes para o banco realizar a trasnferencia
            banco.transferirFundos(pessoaClienteAutenticada, daConta, paraConta, quantia);

          } else if (op == 5) {
            System.out.println("Logout realizado com sucesso!");
            break;
          }

        } while (true);

      }// fim else


    }// fim loop infinito
  }
}
```

</details>

  <details>
      <summary>Exemplo de uso </summary>

Considerando que tenha executado exatamente o c√≥digo da classe `main` acima e interagido como se f√¥ssemos a pessoa cliente Camaragibe Oliveira, ter√≠amos a seguinte intera√ß√£o com o console:

```text
Nova pessoa cliente Alexiania Pereira com CPF: 842.074.410-77 criada!

Nova pessoa cliente Abadiania Silva com CPF: 848.725.510-87 criada!

Nova pessoa cliente Camaragibe Oliveira com CPF: 433.892.200-11 criada!

Bem-vindo ao Banco da Trybe

Entre com seu CPF: 433.892.200-11
Entre com sua senha: 1234

Resumo das Contas da pessoa Camaragibe Oliveira:

1) 1376245820 : R$0.00 : Poupan√ßa

2) 1400842111 : R$0.00 : Corrente

O que voc√™ gostaria de fazer?
  1) Mostrar Extrato
  2) Sacar
  3) Depositar
  4) Transferir
  5) Sair

Entre com sua op√ß√£o: 3
Entre com o n√∫mero (1-2) para selecionar a conta para dep√≥sito: 1
Entre com a quantia de dep√≥sito: R$ 2000

Resumo das Contas da pessoa Camaragibe Oliveira:

1) 1376245820 : R$2000.00 : Poupan√ßa

2) 1400842111 : R$0.00 : Corrente

O que voc√™ gostaria de fazer?
  1) Mostrar Extrato
  2) Sacar
  3) Depositar
  4) Transferir
  5) Sair

Entre com sua op√ß√£o: 3
Entre com o n√∫mero (1-2) para selecionar a conta para dep√≥sito: 2
Entre com a quantia de dep√≥sito: R$ 4000

Resumo das Contas da pessoa Camaragibe Oliveira:

1) 1376245820 : R$2000.00 : Poupan√ßa

2) 1400842111 : R$4000.00 : Corrente

O que voc√™ gostaria de fazer?
  1) Mostrar Extrato
  2) Sacar
  3) Depositar
  4) Transferir
  5) Sair

Entre com sua op√ß√£o: 4
Entre o n√∫mero (1-2) para retirar o valor para transfer√™ncia: 2
Entre o n√∫mero (1-2) para selecionar a conta que receber√° a transfer√™ncia: 1
Entre com a quantia para ser transferida (m√°ximo R$4000.00): R$ 2000

Resumo das Contas da pessoa Camaragibe Oliveira:

1) 1376245820 : R$4000.00 : Poupan√ßa

2) 1400842111 : R$2000.00 : Corrente


O que voc√™ gostaria de fazer?
  1) Mostrar Extrato
  2) Sacar
  3) Depositar
  4) Transferir
  5) Sair

Entre com sua op√ß√£o: 1
Entre com o n√∫mero (1-2) para a conta
que o extrato ser√° impresso: 1

Extrato da conta 1376245820

21/01/2022 14:21:52 -------- Transfer√™ncia recebida: R$ 2000.00 +
21/01/2022 14:21:32 -------- Dep√≥sito recebido: R$ 2000.00 +

Resumo das Contas da pessoa Camaragibe Oliveira:

1) 1376245820 : R$4000.00 : Poupan√ßa

2) 1400842111 : R$2000.00 : Corrente


O que voc√™ gostaria de fazer?
  1) Mostrar Extrato
  2) Sacar
  3) Depositar
  4) Transferir
  5) Sair

Entre com sua op√ß√£o:
```

  </details>

</details>

</details>

</details>

### 1. Criar testes unit√°rios da classe `Transacao`

<details>
    <summary>Descri√ß√£o</summary>

Primeiramente, vamos implementar os testes, e todos ir√£o falhar por enquanto.

`TransacaoTest`: essa classe cont√©m todos os testes relacionados aos m√©todos da classe `Transacao`.

Na classe `TransacaoTest` crie os seguintes cen√°rios de testes:

1. Testa o m√©todo construtor da classe Transa√ß√£o
   - M√©todo `construtorTest`: verifica se o m√©todo construtor est√° inicializando os atributos corretamente.
2. Testa o m√©todo Getter do atributo quantia
   - M√©todo `getQuantiaTest`: testa se o m√©todo `Getter` do atributo quantia est√° retornando a quantia corretamente.
3. Testa o m√©todo retornar resumo transa√ß√£o
   - M√©todo `retornarResumoTransacaoTest`: avalia se o m√©todo `retornarResumoTransacao` apresenta o resumo da transa√ß√£o corretamente.
4. Testa o m√©todo instante est√° gerando o instante corretamente
   - M√©todo `retornarInstanteTest`: verifica se o m√©todo `retornarInstante` retorna o momento correto em que a transa√ß√£o ocorreu, com data, hora, minuto e segundo.

Esses cen√°rios de testes ser√£o os requisitos que nosso avaliador ir√° verificar.

Ap√≥s todos os testes implementados, eles ir√£o falhar, agora √© hora de criar um c√≥digo que funcione e fa√ßa os testes passarem.

Sua implementa√ß√£o deve ter cobertura de testes de 90%

</details>

### 2. Criar testes unit√°rios da classe `Conta` e `PessoaCliente`

<details>
    <summary>Descri√ß√£o</summary>

Vamos implementar os testes, todos devem falhar por enquanto.

`ContaTest`: essa classe cont√©m os testes relacionados aos m√©todos da classe `Conta`.

Na classe `ContaTest` crie os seguintes cen√°rios de testes:

5. Testa o construtor da classe conta
   - M√©todo `construtorTest`: avalia se o construtor est√° inicializando os atributos da classe `Conta` corretamente.
6. Testa o m√©todo adicionar transa√ß√£o e retornar saldo da conta
   - M√©todo `adicionarTransacaoTestRetornarSaldoTest`: verifica se o m√©todo `adicionarTransacao` est√° adicionando ao hist√≥rico da conta uma transa√ß√£o realizada pelo m√©todo em quest√£o, e analisa se o m√©todo `retornarSaldo` retorna o saldo da conta banc√°ria corretamente. Faz sentido testar os dois em conjunto, pois como o m√©todo `adicionarTransacao` n√£o tem retorno, usamos o `retornarSaldo` para verificar se a transa√ß√£o foi adicionada √† conta de forma correta e consequentemente se o saldo est√° sendo retornado sem erros.
7. Testa o m√©todo retornar resumo est√° retornando uma string com os valores corretamente
   - M√©todo `retornarResumoContaTest`: verifica se o m√©todo `retornarResumoConta` est√° apresentando o resumo da conta banc√°ria.
8. Testa o m√©todo retornar extrato est√° imprimindo os valores corretamente
   - M√©todo `retornarExtratoTest`: testa se o m√©todo `retornarExtrato` est√° apresentando o extrato da conta banc√°ria.
9. Testa o m√©todo Getter do atributo idConta est√° retornando
   - M√©todo `getIdContaTest`: avalia se o m√©todo `Getter` do atributo `idConta` est√° retornando o n√∫mero identificador da conta.
10. Testa o m√©todo m√©todo Getter do atributo pessoaCliente est√° retornando
    - M√©todo `getPessoaClienteTest`: verifica se o m√©todo `Getter` do atributo `pessoaCliente` est√° retornando a pessoa cliente da conta banc√°ria.

`PessoaClienteTest`: essa classe possui os testes dos m√©todos da classe `PessoaCliente`.

Na classe `PessoaClienteTest` crie os seguintes cen√°rios de testes:

11. Testa o construtor da classe Pessoa Cliente
    - M√©todo `construtorTest`: avalia se o construtor da classe est√° inicializando seus atributos corretamente e imprimindo no console uma mensagem indicando que um objeto da classe `PessoaCliente` foi instanciado com sucesso.
12. Testa o m√©todo adicionar conta e o m√©todo retornar n√∫mero de conta
    - M√©todo `adicionarContaTestRetornaNumeroDeContasTest`: verifica se o m√©todo `adicionarConta` est√° adicionando nova conta para pessoa cliente e tamb√©m analisa se o m√©todo `retornaNumeroDeContas` retorna o n√∫mero que representa a quantidade de contas que uma pessoa cliente possui. Faz sentido testar esses dois m√©todos juntos, pois o m√©todo `adicionarConta` n√£o tem retorno, ent√£o usamos o m√©todo `retornarNUmeroDeContas` para verificar se a conta foi adicionada e j√° aproveitamos para testar o seu funcionamento.
13. Testa o m√©todo retornar saldo de uma conta espec√≠fica da pessoa cliente
    - M√©todo `retornarSaldoContaEspecificaTest`: testa se o m√©todo `retornarSaldoContaEspecifica` retorna o saldo de uma conta banc√°ria espec√≠fica corretamente.
14. Testa o m√©todo retornar id de uma conta espec√≠fica da pessoa cliente
    - M√©todo `retornarIdContaEspecificaTest`: verifica se o m√©todo `retornarIdContaEspecifica` est√° retornando o n√∫mero identificador de uma conta banc√°ria espec√≠fica corretamente.
15. Testa o m√©todo retornar o extrato de uma conta espec√≠fica da pessoa client
    - M√©todo `retornarExtratoContaEspecificaTest`: avalia se o m√©todo `retornarExtratoContaEspecifica` retorna o extrato banc√°rio de uma conta espec√≠fica da pessoa cliente.
16. Testa o m√©todo adiciona transa√ß√£o de uma conta espec√≠fica da pessoa cliente
    - M√©todo `adicionarTransacaoContaEspecificaTest`: testa se o m√©todo `adicionarTransacaoContaEspecifica` est√° adicionando uma transa√ß√£o a uma conta espec√≠fica da pessoa cliente,
17. Testa o m√©todo validar senha
    - M√©todo `validarSenhaTest`: testa se o m√©todo `validarSenha` est√° verificando se a senha passada por par√¢metro √© a mesma que foi cadastrada ao criar a pessoa cliente.
18. Testa o m√©todo retornar resumo contas
    - M√©todo `retornarResumoContasTest`: analisa se o m√©todo `retornarResumoContas` retorna o resumo das contas da pessoa cliente.
19. Testa o m√©todo Getter do atributo cpf est√° retornando
    - M√©todo `getCpfTest`: avalia se o m√©todo `Getter` do atributo `cpf` da pessoa cliente est√° retornando o CPF cadastrado.

Esses cen√°rios de testes ser√£o os requisitos que nosso avaliador ir√° verificar.

Ap√≥s todos os testes implementados, eles ir√£o falhar, agora √© hora de criar um c√≥digo que funcione e fa√ßa os testes passarem.

Sua implementa√ß√£o deve ter cobertura de testes de 90%

</details>

### 3. Criar testes unit√°rios da classe `Banco`

<details>
    <summary>Descri√ß√£o</summary>

Vamos implementar os testes, todos devem falhar por enquanto.

- `BancoTest`: essa classe cont√©m todos os testes relacionados aos m√©todos da classe `Banco` do nosso sistema de caixa eletr√¥nico.

Na classe `BancoTest` crie os seguintes cen√°rios de testes:

20. Testa o gerador de n√∫mero √∫nico para nova conta

- M√©todo `gerarNumeroNovaContaTest`: verifica se o m√©todo `gerarNumeroNovaConta` est√° retornando uma String de 10 d√≠gitos, que representam o n√∫mero da nova conta aberta.

21. Testa o m√©todo adicionar pessoa cliente retorna o objeto pessoa cliente

- M√©todo `adicionarPessoaClienteTest`: testa se o m√©todo `adicionarPessoaCliente` est√° adicionando objetos do tipo `PessoaCliente` ao array `pessoasClientes` dessa classe `Banco`. Representa a inser√ß√£o de novas pessoas clientes ao banco, e retorna ao objeto da classe `PessoaCliente`.

22. Testa o m√©todo login da pessoa cliente retorna o objeto pessoa cliente corretamente

- M√©todo `pessoaClienteLoginTest`: verifica se o m√©todo `pessoaClienteLogin` libera o acesso de pessoas clientes e pro√≠be acessos com combina√ß√£o de CPF e senha errados.

23. Testa se o m√©todo transferir fundos est√° transferindo corretamente

- M√©todo `depositarTestTransferirFundosTestMostrarExtratoTest`: testa se o m√©todo `depositar` est√° adicionando ao saldo da conta banc√°ria o valor que √© passado como argumento, e `transferirFundos` est√° transferindo quantias em dinheiro entre as contas da pessoa cliente. Tanto o m√©todo `deposito` quanto o m√©todo `transferirFundos` n√£o retornam valores, por isso usamos o m√©todo `mostrarExtrato` para imprimir no console e verificarmos sua impress√£o. Com isso, faz sentido que voc√™ utilize os tr√™s em um m√©todo de teste √∫nico, pois para poder transferir valores de uma conta para outra, a conta que ceder√° o dinheiro dever√° ter um saldo positivo.

24. Testa se o m√©todo sacar est√° funcionando corretamente

- M√©todo `depositarTestSacarTestMostrarExtratoTest`: testa se o m√©todo `depositar` est√° adicionando ao saldo da conta banc√°ria o valor que √© passado como argumento, e o m√©todo `sacar` est√° realizando a subtra√ß√£o correta do saldo em conta banc√°ria da quantia que √© passada como argumento. Como o m√©todo `depositar` e o m√©todo `sacar` n√£o retornam valores, voc√™ deve usar o m√©todo `mostrarExtrato` para imprimir no console e verificar sua impress√£o. Com isso, faz sentido testar os tr√™s em um m√©todo de teste s√≥, pois para poder sacar valores de uma conta, ela dever√° ter um saldo positivo.

Esses cen√°rios de testes ser√£o os requisitos que nosso avaliador ir√° verificar.

Ap√≥s todos os testes implementados, eles ir√£o falhar, agora √© hora de criar um c√≥digo que funcione e fa√ßa os testes passarem.

Sua implementa√ß√£o deve ter cobertura de testes de 90%

</details>

### 4. Cobertura de Teste Superior a 90%

<details>
    <summary>Descri√ß√£o</summary>

    Se tudo correu bem, sua aplica√ß√£o j√° deve estar com cobertura de 90%. Caso n√£o esteja, ser√° necess√°rio implementar mais alguns cen√°rios de testes. M√£os a obra, bora chegar nesses 90%.

    Quantos testes n√£o!? üòÖ

</details>
